<!DOCTYPE html>
<html>
<head>
    <title> CAT Final Report </title>
</head>
<body>

<h1> CAT Final Report </h1>
<p> Noah Apthorpe, Garrett Disco, Luke Paulsen, Jocelyn Tang, Natalie Weires </p>
<p> Princeton University, COS 333, Spring 2013 (TA: Hao Wu) </p>

<h2> Milestones </h2>
<p> We generally kept up well with our milestones, although some of them were completed in a different order than we expected. A brief summary of our goals and what we actually accomplished follows: </p>
<h3> March 22 </h3>
<p> Over spring break, our goal was to get MongoDB set up and working, get AWS set up and working, and begin scraping data from the Registrar. (Django was already set up and working on localhost when we finalized our timeline.) Natalie successfully set up MongoDB and the scraping system, and defined much of the database structure (based on the structure of Registrar information). However, we did not get AWS set up for a long time after this. This was partially because the Django runserver was very effective for development and testing, and partially because we were expecting to be hosted by OIT and/or Tigerapps (which has not yet come through).</p>
<h3> March 29 </h3>
<p> For this date, our goal was to have the whole structure of the site up and working in a minimal fashion: Mongo, Django, and Javascript all interacting correctly, and the database structure (all information needed for any given course) clearly defined. We met this goal easily, with the exception of setting up the database to handle course reviews (which are provided on a separate website from the Registrar website and turned out to be quite challenging to access). By the end of this week, we had a working search interface where we could type in a course subject and/or number and get a clickable list of results and course data back from the database, which went considerably beyond what we had expected to accomplish. </p>
<h3> April 5 </h3>
<p> For this date, our goal was to scrape all available course data from the Registrar and display it on the frontend (which was already accomplished, except for reviews, the week before). Additionally, our goal was to decide on a final design for the frontend and be able to search, filter, and/or rank courses by any category. This proved to be a less realistic goal. Although we made major frontend improvements during this week and expanded the kinds of queries that the search bar could handle, we did not achieve full functionality on this front until later. </p>
<h3> April 12 </h3>
<p> For this date, our goal was to implement the CAS login wall, show the search bar and results on the frontend, and handle difficult corner cases when scraping courses. Of these, the last two were already more or less complete by this point, and the first remained an unsolved problem unitl two weeks later. What we did accomplish this week was to add course review scraping to the database and add the ability to save courses in a "cart" across sessions. This is also the point at which we made a lot of the final decisions regarding the UI design and the protocol for UI/Django interaction. </p>
<h3> April 19 </h3>
<p> For this date, our goal was to implement interactive features (such as tabbing between semesters, choosing which data to display, switching between multiple courses at once, and saving user data) on the frontend, and to test the system's protection against basic attacks. Because we had by this point significantly modified our original frontend design, several of these goals were no longer relevant (we didn't plan to display multiple courses at once or dynamically modify which data was displayed), and saved user data and tabbing were already a reality. We didn't carry out any formal tests of our system's security at this point, but between Django's built-in protections and the use of CatDB to access Mongo, we were confident that it would be difficult to attack our database. During this week, we continued to increase the number of categories of data that could be displayed and searched by.</p>
<h3> April 26 </h3>
<p> For this date, our goal was to finalize the frontend navigation system and begin implementing additional, "cool" features. We did in fact do our final major UI overhaul during this week, which gave us much of the current look of the site. This is also the point at which we added a way to display course reviews, which was the one major piece of information that the site had been missing, and finally implemented the CAS login system in order to protect the review data. The one major "additional" feature we considered adding was an "analyze" button to get combined data about courses in the cart; this ended up getting scrapped, since it was unlikely to be sufficiently useful given the amount of work we would be able to put into it. </p>
<h3> May 3 </h3>
<p> For this date, our goal was to finish making the frontend styles and the additional features. That is pretty much what we did: we added the course-review graphing and color-coding systems, added a top bar with intuitive login/logout functionality, added a few more search queries and improved some others, improved the display of course data and review data, and finally decided on what background to use (which had been a major point of contention. By this point, nearly all major features were implemented and working correctly, and we deployed the system for beta testing.</p>
<h3> May 10 </h3>
<p> By this date, we planned to finalize the software and prepare the demo and presentation. This was our presentation date, so clearly we accomplished these goals (although a few bugs in the software were fixed after the demo). As of this date, we had a complete database going back to 2010, a fully functional searching and ranking system, a system for displaying all available course data, and even our own domain (princetoncat.org). This was effectively the end of the CAT development process and at this point we have met all of our major goals for the program. </p>

<h2> What was your experience with design, interfaces, testing, etc.? </h2>
<p> We started out design process early on, with the entire group present. We first identified the key features of our app (which ended up changing over time), and then split up into UI and Back-end teams to design (without implementing anything) how the architecture was going to work on both ends. After each team had come up with a design, we met together again to critique and finalize these designs, and also to come up with a great protocol for communication between the two sides. Specifically, we decided exactly when requests would be made and what the database would return at each step. Because we thought about this so far in advance, our final product is able to fetch most data well in advance of when the user actually needs it, thus making for a more seamless user experience.</p>

<p> The design of our user interface changed a lot during the early stages of the project. Even though we ended up not using a lot of what we originally planned, it was tremendously helpful to work through different iterations of the ideas and mentally test how the user experience would feel. For example, the single webpage with a main unit for searching and viewing was part of our original plan; the course cart came in as part of a later plan that got scrapped, and the main course data area was originally supposed to be a preview of the course information until we realized that it could hold a lot of information.</p>

<p>Actual testing of our code was minimal and spotty. In general, if after creating a new feature we could do a run through of the basic use case (search for "COS", view registrar data for COS 126, see reviews, add to cart) and nothing broke, that was sufficient to push to master. We ended up introducing a lot of bugs this way, including some that have only recently been fixed (and possibly some that we have failed to detect).</p>

<p>Eventually we started doing intentional testing of the app, but this mostly consisted of coming up with the strangest plausible queries we could think of and seeing if the app behaved in a way that was not an obvious catastrphic failure. We also tried searching for the entire text of Genesis 1 and 2, which causes the app to hang (go ahead, try it) but does not affect performance for other users, which we think is a reasonable response.</p> 

<h2> What surprises, pleasant or otherwise, did you encounter on the way? </h2>
<h3>Surprise #1: Unpleasant</h3>
<p>In the first few weeks of the project, we had meetings with the USG, who showed a lot of support and excitement for the project. We initially thought we would be able to host our site on the their server but realized that this was more complicated than we thought, for a few reasons. First, communication between our team and the USG was sometimes not the best (ie, they were not always good at replying promptly), and also, they were used to using php for TigerApps, and it was unclear how we could get Django set up.</p>
<p>After realizing that we probably wouldn't be able to host on the USG servers, we decided to host on ec2 servers, which was generally straightforward. We did, however, encounter a problem when we accidentally locked ourselves out of the ec2 instance and had to restart everything.</p>

<h3>Surprise #2: Unpleasant</h3>
Getting CAS to work also proved more difficult than we expected, because Professor Kernighan's code, though it was very helpful, was not designed for Django. After we got that to work, however, we still had to wait for approval from OIT to get white-listed. Overall this was slightly inconvenient but not too frustrating.</p>

<h3>Surprise #3: Unpleasant</h3>
Interpreting searches was not as easy or intuitive as we thought it would be. We originally decided to parse text searches (ie, those that were not related to other specific searches like distribution requirement, days of week/times, etc) by first checking if the word was a professor name - if so, we just matched classes with that professor name. If not, we labeled it a keyword and counted the number of times the keyword appeared in a course title or description (weighting it more if it was in the title), and returned searches in the order of relevance (most matches). We realized that this works for the most part, but certain keywords are also professor names - like Christian, Black, White, Green, etc. We decided that the only way to really solve for this was to have special cases for certain words/names, but overall it was a strange and slightly unpleasant surprise.</p>
<p>Another case where search was a bit ambiguous was interpretation of day/time searches. We had a few disagreements on whether MWF meant classes that met on Mondays, Wednesdays, and Fridays, or if it meant classes that met on Mondays, Wednesdays, or Fridays. In the end we decided to use "or", but we still feel that users could mean both.</p>

<h3>Surprise #4: Pleasant</h3>
<p>We weren't sure how what was needed to get Mongo to work on the ec2 setup, but as it turned out it integrated naturally with Apache and caused no problems at all (except that we were confused when we tried to run it and saw that it was already being run automatically).</p>

<h3>Surprise #5: Pleasant</h3>
<p>jQuery ended up working out really well; every time we wanted jQuery to do something, it existed as a built-in jQuery function and was named exactly as we expected it to be named. The intuitive nature of jQuery was pleasantly surprising. </p>

<h2> What choices did you make that worked out well or badly? </h2>
<p> We started our project early, getting the basic database built over spring break. This included defining an interface through which the database could be accessed, which let us start building the middle and front layers of the site while still making changes to how the database was structured and built. Similarly, we split up the various components of the project in a way that let us work indivually or in pairs on sections separately, but so that the pieces worked together well.</p>

<p> Unlike many groups, we decided not to use Twitter Bootstrap to design our app's style and layout. This gave us more freedom to design features in novel ways. For example, no other search engine we have observed brings back search results on the left and detail views of search results on the right. We think that this is one of our app's best features, as it allows you to search, browse results, and read registrar and review data all without reloading the page. On the other hand, we sacrificed the polished look that all Twitter Bootstrap sites have in common, which may have a negative impact on our users.</p>

<p> At the very beginning of the project, we talked to USG about making our site a TigerApp. While they were excited and wanted to be involved, actually getting our project hosted with them didn't happen quickly enough for us to keep making progress, so we ended up hosting on an Amazon EC2 server. While there are plans to eventually move CAT to USG servers, trying to make this happen during the semester didn't work out. </p>

<h2> What would you like to do if there were more time? How would you do things differently next time? </h2>
<p> One of the most frustrating parts of designing CAT was not getting to include all the features we had in mind. We overestimated how long it would take to implement what we consider our "core platform," namely, the user interface, the search functionality, and the ability to see graphs of reviews. A major feature we did not have time to implement was an "Analyze" feature for courses in the cart. This feature would have analyzed Registrar data to compile statistics on the total workload required to complete all of the courses in the cart. For example, we might have reported on the number of midterms, finals, pages of reading per week, Dean's Date papers, etc, and displayed these results in a slick graph.</p>

<p> We would also have liked to implement connectivity with ICE in the form of a button that would populate ICE with the courses in your cart. This feature would really make CAT the go-to place for course searching by providing easy access to the current most popular course-related app. </p>

<p> If we had the chance to do it again, one of the first things we would do is organize our code better. We started with a demo jQuery website with all of the javascript in a file called index.js, and the css in a file called index.css. Somehow in the process of turning that jQuery demo into CAT, we never broke up those files, such that index.js is now about 600 lines long, index.css is about 800 lines long, and both of them are essentially unordered collections of miscelaneous functions and classes that we added as we went along. Keeping these files better organized would have made later development and bug fixing much easier.</p>

<p> We also would put more thought into styling the app. Consistent with our choice not to use Twitter Bootstrap, we focused first and foremost on functionality and layout, and thus left the "minor details" of fonts, color, background, etc. up to whoever happend to be working on that feature at the time. Due to differences in taste and the lack of a framework like Bootstrap, we ended up with some inconsistent styling that had to be resolved through much debate within the group, and a final product that lacks the polished look of a Bootstrap-driven site.</p> 

<h2> What should next year's class learn from your experience? Imagine that you are writing this document for your (friendly!) boss or professor and want to explain what you learned that could be applied to the next project.</h2>
<p> Get started early. That means both choosing a project and group early in the semester and actually starting to build things as soon as is reasonable. Have a clear idea of what you want your site/app/whatever to be able to do, and focus on getting the basic features implemented before trying to do fancy things. Likely, the basic functionality will take longer to implement than you expect. Have a clear division of labor, so everyone knows what they are responsible for and when they need to get it done. </p>
<p> It's important to make good choices of what systems to use. There might be some approaches that would be good for a longer-term project but are not so good for a short project like this one. It's important to make sure that for every tool you use, there is at least someone in your group that understands it. We used a stack of Mongo, Django, custom CSS, and jQuery, which turned out to be powerful and flexible without requiring too much work to set up.</p>

</body>
</html>
